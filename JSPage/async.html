<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="viewport" content="width=devich-width, initial-scale=1">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>Shinhwa</title>
  <link href="../css/bootstrap.css" rel="stylesheet">
  <link rel="shortcut icon" href="../favicon.ico" />
  <script src="../js/jquery.js"></script>
  <script src="../js/bootstrap.min.js"></script>
  
  <style>
  .textIndent{text-indent:2em;line-height:2em}
  .line{height:1px;border-top:1px solid red;margin-bottom:10px}
  .title{background-color:#7777A4;padding:10px;color:white}
  .clearMB{margin-bottom:0!important}
  .mt{margin-top:50px}
  </style>
 </head>
 <body>
  <div class="navbar navbar-default navbar-fixed-top">
	<div class="navbar-header">
		<button data-toggle="collapse" class="navbar-toggle" data-target=".navbar-responsive-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="../homePage.html">AJAX</a>
	</div>
	<div class="collapse navbar-collapse navbar-responsive-collapse">
		<ul class="nav navbar-nav">
			<li><a href="#do">JS执行机制</a></li>
			<li><a href="#promise">延迟对象</a></li>
		</ul>
	</div>
 </div>
 <div class="container mt">
	<div class="row">
		<div class="col-lg-12">

		<h3 class="title" id="do">JS执行机制</h3>
		<p class="textIndent">首先看一个例子</p>
		<pre>
		for(var i=0;i&lt3;i++){
			setTimeout(function(){console.log(i)},0);
		}
		//此时我们期望的结果是：0,1,2
		//但是实际的结果却是：3,3,3
		</pre>
		<p class="textIndent">JS是一种单线程的语言。单线程就表示JS中所有的任务都是排队执行的，
		我们可以将这条线程称为
		"执行线程"。当我们写的JS程序在执行环境(这指浏览器)中开始执行的时候，首先会触发变量提升这一机制，
		然后从上向下开始执行代码。但是在JS执行的过程中如果碰上了事件处理，定时器浏览器则会新开一个
		线程我们可以称为"消息队列"来保存对应的事件处理函数和
		定时器的处理函数，当"执行线程"执行完毕后，"执行线程"会
		告诉"消息队列"，如果"消息队列"中有已经准备执行的处理函数，则处理函数会放入到"执行线程"中开始
		执行。</p>
		<p class="textIndent">首先说明一下setTimeout的机制为：在执行时间之后会把前面的表达式放入到
		"执行队列"中。第一个列子JS在执行的过程，在第一次循环中碰上了setTimeout，所以执行环境会把
		"function(){console.log(i)}"放在"消息队列"中此时i=0,"执行线程"的循环继续执行，
		执行第二次循环的时候，仍然把"function(){console.log(i)}"放在"消息队列"中此时i=1,执行第三次
		循环的时候，仍然把"function(){console.log(i)}"放在
		"消息队列"中此时i=2，然后执行i++,此时i=3不在满足循环条件，至此"执行线程"执行完毕，"执行线程"
		通知"消息队列"，此时"消息队列"中三个表达式开始执行，分别打印i，而此时i=3。</p>
		<p class="textIndent">我们可以通过以下方式来实现我们想要的结果</p>
		<pre>
		for(var i=0;i&lt3;i++){
			setTimeout((function(i){
				return function(){
					console.log(i);
				}
			}(i)),0);
		}
		</pre>
		<p class="textIndent">此时setTimeout第一个参数上一个立即执行的函数，函数执行完成之后会返回
		一个函数表达式即function(){console.log(i)}，在将这个函数放在"消息队列"中此时i指向我们传递
		进去的参数</p>
		<div class="line"></div>
		<h3 class="title" id="promise">延迟对象</h3>
		<p class="textIndent">通过JS的执行机制我们已经知道了只有"执行线程"执行完成之后，才会执行"消息
		队列"里的语句。</p>
		<p class="textIndent">比如我们都这个一个小需求：点击一个按钮，生成一个p元素，然后设置p元素的文本
		内容。我们可能会这样来实现</p>
		<pre>
		$(function(){
			var btnOfCreate = $(".addButton");
			btnOfCreate.click(function(){
				var divDom = $("&ltp&gt&lt/p&gt");
				$("body").append(divDom);
			});
			$("p").html(123);
		})
		</pre>
		<p class="textIndent">上面的代码是不能实现我们期望的效果的，因为这段代码会先执行<code>
		$("p").html(123)</code>而此时p元素还不存在。</p>
		<p class="textIndent">对于这种简单的要求我们可以吧设置内容的语句放在点击事件的回调函数中
		这样也可以实现我们期望的效果。当时当我们的需求非常复杂时，我们如果把任何逻辑都写在回调函数
		中，代码会变得非常的复杂，不利于维护。此时我们就可以利用延迟对象来实现我们的需求，同时
		代码易于维护。</p>
		<p class="textIndent">延迟对象即让语句推迟执行。</p>
		<pre>
		$(function(){
			var def = new $.Deferred();
			var btnOfCreate = $(".addButton");
			btnOfCreate.click(function(){
				var divDom = $("&ltp&gt&lt/p&gt");
				$("body").append(divDom);
				def.resolve();
			});
			def.done(function(){
				$("p").html(123);
			})
		})
		//这段代码达到了我们的需求
		</pre>
		<p class="textIndent">$.Deferred()是JQ为我们实现的延迟对象。延迟对象具有三种状态。</p>
		<p class="textIndent">pendding:未完成这是延迟对象创建成功是默认的状态。</p>
		<p class="textIndent">resolved:操作成功，当延迟对象调用resolve()方法时，延迟对象的
		状态会转变为resolved，会执行done()里面的语句</p>
		<p class="textIndent">rejected:操作失败，当延迟对象调用reject()方法是，延迟对象的状态
		会转变为resolved，会执行fail()里面的语句</p>
		<p class="textIndent">一个延迟对象只能从pending状态转换为resolved或者rejected不存在别的
		情况，而且不管转换为哪一种状态always里面的语句一定会被执行。</p>
		<pre>
		//使用时首先创建一个延迟对象
		var def = new $.Deferred();
		//定义好成功时需要执行的语句
		def.done(function(){do sth……});
		//定义好失败是需要执行的语句
		def.fail(function(){do sth……});
		//如果def调用了def.resolve()方法则def.done()里面的语句将会被执行
		//如果def调用了def.reject()方法测def.fail()里面的语句将会被执行
		</pre>
		<p class="textIndent">同时def.resolve()与def.done()之间是可以进行参数传递的。def.done()里面的函数
		语句可以接收到def.resolve()传递过去的参数</p>
		<pre>
		$(function(){
			var def = new $.Deferred();
			var btnOfCreate = $(".addButton");
			btnOfCreate.click(function(){
				var divDom = $("&ltp&gt&lt/p&gt");
				$("body").append(divDom);
				def.resolve("哈哈哈哈");
			});
			def.done(function(arg){
				$("p").html(arg);
			})
		})
		//p的文本内容为->哈哈哈哈
		</pre>
		<p class="textIndent">在我们平时的开发中，我们需要的数据可能来自于不同的数据接口，而我们又
		需要把这些数据放在一起显示。这时候就很适合使用延迟对象来实现例如：</p>
		<pre>
		$(function(){
			var def = new $.Deferred();
			$.ajax({
				url:"/Account/getViewList",
				type:"post",
				success:function(data){
					def.resolve(data);
				}
			})
			def.done(function(otherData){
				$.ajax({
					url:"/Account/getTableList",
					type:"post",
					success:function(data){
						//在这我们可以同时操作两个接口取到的数据
					}
				})
			})
		})
		</pre>
		<p class="textIndent">或者我们可以通过$.when()来实现</p>
		<pre>
		$(function(){
			var allData = {};
			var viewPromise = $.get(url).done(function(data){allData.viewData = data;});
			var tablePromise = $.get(url).done(function(data){allData.tableData = data;});
			$.when(viewPromise,tablePromise).done(function(){ use allData to do sth……});
		})
		</pre>
		</div>
	</div>
 </div>
 <div class="navbar navbar-default clearMB">
		<div class="container">
		</div>
	</div>
 </body>
</html>
