<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=devich-width, initial-scale=1">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="shinhwa的博客">
  <meta name="Description" content="">
  <title>Shinhwa</title>
  <link href="../css/bootstrap.css" rel="stylesheet">
  <link rel="shortcut icon" href="../favicon.ico" />
  <script src="../js/jquery.js"></script>
  <script src="../js/bootstrap.min.js"></script>
  
  <style>
  .textIndent{text-indent:2em;line-height:2em}
  .line{height:1px;border-top:1px solid red;margin-bottom:10px}
  .title{background-color:#7777A4;padding:10px;color:white}
  .clearMB{margin-bottom:0!important}
  .mt{margin-top:50px}
  </style>
 </head>
 <body>
 <div class="navbar navbar-default navbar-fixed-top">
	<div class="navbar-header">
		<button data-toggle="collapse" class="navbar-toggle" data-target=".navbar-responsive-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="../homePage.html">this</a>
	</div>
	<div class="collapse navbar-collapse navbar-responsive-collapse">
		<ul class="nav navbar-nav">
			<li><a href="#this">this</a></li>
			<li><a href="#cathis">call,apply改变this指向</a></li>
			<li><a href="#caarg">call,apply参数传递</a></li>
			<li><a href="#bind">bind</a></li>
		</ul>
	</div>
 </div>
	 
	<div class="container mt" >
		<div class="row">
			<div class="col-lg-12">
			<h3 class="title" id="this">this</h3>
			<p class="textIndent">this永远指向调用函数的那个对象</p>
			<pre>
			var arr = [];
			var obj = {};
			arr.Function();//Function()中的this就指向arr
			obj.Function();//Function()中的this就指向obj
			</pre>
			<p class="textIndent">this永远指向调用函数的那个对象，但是在平时的开发中两种情况下我们需要
			注意，一种是在事件函数中，另一种是在定时器中</p>
			<p class="textIndent">正常情况下</p>
			<pre>
			function Me(){
				this.name = "zt";
				this.age = 22;
			}
			Me.prototype.say = function(){
				console.log("我是"+this.name+"年龄"+this.age);
			}
			var me = new Me();
			me.say();//我是zt年龄22
			</pre>
			<p class="textIndent">定时器中</p>
			<pre>
			function Me(){
				this.name = "zt";
				this.age = 22;
			}
			Me.prototype.say = function(){
				setTimeout(function(){
					console.log("我是"+this.name+"年龄"+this.age);
				})
			}
			var me = new Me();
			me.say();//此时会提示undefined
			</pre>
			<p class="textIndent">上面出现undefined的原因在于，setTimeout的中的匿名函数时由window对象来
			执行的而window对象中没有name和age两个属性，在事件函数中同样是这样的情况，所以在应用
			this时要注意着两种情况，我们可以通过下来的方法来避免这两种情况。</p>
			<pre>
			function Me(){
				this.name = "zt";
				this.age = 22;
			}
			Me.prototype.say = function(){
				var _this = this;
				setTimeout(function(){
					console.log("我是"+_this.name+"年龄"+_this.age);
				})
			}
			var me = new Me();
			me.say();//我是zt年龄22
			//这种情况下我们把this变量保存起来，不管setTimeout中的函数由谁调用，都去寻找me对象下的属性
			</pre>
			<p></p>
			<pre>
			function Me(){
				this.name = "zt";
				this.age = 22;
			}
			Me.prototype.say = function(){
				var _this = this;
				setTimeout(function(){
					return function(){
						console.log("我是"+this.name+"年龄"+this.age);
					}.call(_this)
				})
			}
			var me = new Me();
			me.say();//我是zt年龄22
			//改变setTimeout执行时的this的指向
			</pre>
			<p class="textIndent">在JS中我们可以使用三种方式来改变函数运行时的this的指向。分别为call、
			apply、bind</p>
			<p class="textIndent">三种方法都可以改变this的指向，call、apply在使用时函数会立即执行，而bind
			则是创建一个新的函数，并返回这个函数，函数内的this就是bind内传递的参数</p>
			<p class="textIndent">call、apply在使用时也有不同。call可以接收多个参数，第一个参数表示this的
			指向，后面的参数则表示函数的参数，apply最多只能接收两个参数，第一个参数表示this的指向，第二个
			参数是一个数组，表示函数的参数。</p>
			<div class="line"></div>
			<h3 class="title" id="cathis">call,apply改变this的指向</h3>
			<p class="textIndent">我们已经知道call可以改变函数中的this的指向，call()函数可以接收多个参数
			，第一个参数表示this的一个指向，后面的参数会作为实参传递到要执行的函数中。</p>
			<pre>
			//首先顶一个构造函数
			function Plant(){
				this.flag = "我是植物";
			}
			Plant.prototype.transition = function(){
				console.log(this.flag+":我可以进行光合作用");
			}
			function Animal(){
				this.flag = "我是动物";
			}
			Animal.prototype.sport = function(){
				console.log(this.flag+":我可以行走")
			}
			//新建对象
			var tree = new Plant();
			var dog = new Animal();
			//正常情况下函数调用
			tree.transition();//我是植物：我可以进行光合作用
			dog.sport();//我是动物：我可以行走
			</pre>
			<p>在上面的代码中我们知道了植物对象可以进行光合作用，动物对象可以进行运行。
			我们可以通过改变this的指向可以让动物对象也具有光合作用(忽略实际情况……)</p>
			<pre>
			tree.transition.call(dog);//我是动物：我可以进行光合作用
			</pre>
			<p class="textIndent">apply在改变this指向时和call的用法是一致的，不同之处在于向函数中传递
			参数<p>
			<div class="line"></div>
			<h3 class="title" id="caarg">call,apply对参数的处理</h3>
			<pre>
			function Goods(kind){
				this.kind = kind;
				this.createTime = "明天";
				this.shelfLife = "1天"
			}
			Goods.prototype.sell = function(place,area){
				console.log("商品种类："+this.kind+"生产日期："+this.createTime+"保质期："+this.shelfLife+"发往"+place+"市"+area);
			}
			var milk = new Goods("牛奶");
			milk.sell();//商品种类：牛奶生产日期：明天保质期：1天发往北京市上地
			var book = {
				kind:"书籍",
				createTime:"明天",
				shelfLife:"1天",
			}
			Goods.prototype.sell.call(book,"上海","陆家嘴")//商品种类：书籍生产日期：明天保质期：1天发往上
			海市陆家嘴
			//此时我们将调用sell函数的对象改为book，同时将<code>"上海","陆家嘴"</code>两个参数作为实际参数
			传递给sell函数
			var toy = {
				kind:"玩具",
				createTime:"明天",
				shelfLife:"1天",
			}
			Goods.prototype.sell.apply(toy,["深圳","南山"])//商品种类：玩具生产日期：明天保质期：1天发往深
			圳市南山
			//apply第二个参数是一个数组，会把数组里面的元素作为参数传递给sell函数
			</pre>
			<div class="line"></div>
			<h3 class="title" id="bind">bind</h3>
			<p class="textIndent">call和apply在使用时会立即执行前面的函数，而bind则是新建一个函数，
			将新建函数的this指向bind()函数的第一个参数，然后返回这个新建的函数</p>
			<pre>
			//继续上面的代码
			var pinao = {
				kind:"钢琴",
				createTime:"明天",
				shelfLife:"1天",
			}
			Goods.prototype.sell.bind(pinao,"XX","YY")();//商品种类：钢琴生产日期：明天保质期：1天发往
			XX市YY
			</pre>
			</div>
		</div>
	</div>
	<div class="navbar navbar-default clearMB">
		<div class="container">
		</div>
	</div>
 </body>
</html>
