<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=devich-width, initial-scale=1">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>Shinhwa</title>
  <link href="../css/bootstrap.css" rel="stylesheet">
  <link rel="shortcut icon" href="../favicon.ico" />
  <script src="../js/jquery.js"></script>
  <script src="../js/bootstrap.min.js"></script>
  <style>
  .textIndent{text-indent:2em;line-height:2em}
  .line{height:1px;border-top:1px solid red;margin-bottom:10px}
  .title{background-color:#7777A4;padding:10px;color:white}
  .clearMB{margin-bottom:0!important}
  .mt{margin-top:50px}
  </style>
  <script>
  
  
  </script>
 </head>
 <body>
   <div class="navbar navbar-default navbar-fixed-top">
	<div class="navbar-header">
		<button data-toggle="collapse" class="navbar-toggle" data-target=".navbar-responsive-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="../homePage.html">继承</a>
	</div>
	<div class="collapse navbar-collapse navbar-responsive-collapse">
		<ul class="nav navbar-nav">
			<li><a href="#proto">原型链</a></li>
			<li><a href="#extend">函数继承</a></li>
			
		</ul>
	</div>
 </div>
 <div class="container mt">
	<div class="row">
		<div class="col-lg-12">
		<h3 class="title" id="proto">原型链</h3>
		
		<p class="textIndent">JS的继承是基于原型链的</p>
		<pre>
		var a = {a:1,b:2};//创建一个对象,对象创建时会自动创建一个__proto__属性
		此时对象a为：
		{
			a:1,
			b:2,
			__proto__:Object
		}
		此时对象a的作用域链为：a -__proro__->Object.prototype
		测试如下：
		Object.prototype.c = 3;
		console.log(a.c);//3
		对象在访问属性的时候首先会在自身下面寻找该属性，如果自身下属性不存在，则会通过原型链向父级去
		查找该属性，如果还不存在则继续向上查找，一直找到原型链的末端(Object.prototype),如果仍然不存在
		则会返回undefined
		</pre>
		<p style="color:red" class="textIndent">prototype属性只存在Object和函数对象上</p>
		<p class="textIndent">Object.create()函数可以创建一个新对象，新对象的原型链指向函数的第一个参数
		</p>
		<pre>
		var a = {a:1,b:2};
		var b = Object.create(a);
		//此时b的原型链为：b-__proro__->a-__proro__->Object.prototype
		测试如下：
		b.flag = "b";
		a.flag = "a";
		Object.prototype.flag = "op";
		console.log(b.flag)//b
		//b.flag = "b"注释之后结果为a
		//b.flag = "b";a.flag = "a";这两个注释之后结果为op
		//对象在访问属性的时候会沿着原型链进行查找，找到属性之后就会返回
		</pre>
		<div class="line"></div>
		<h3 class="title" id="extend">函数继承</h3>
		<p class="textIndent">JS函数的继承是通过原型链来实现的</p>
		<p class="textIndent">继承是面向对象的一个特性，继承的过程就是一个从普遍到特殊的过渡，我们把目标的
		公共的部分抽取出来作为父类，每一个子类从父类中派生，这样子类既有公共的部分，又有自己独有的部分</p>
		<p class="textIndent">一个简单的继承如下：</p>
		<pre>
		function People(name,age){
			this.name = name;
			this.age = age;
		}
		People.prototype.say = function(){
			console.log("I can say");
		}
		function Adult(name,age,job){
			People.call(this,name,age);
			this.job = job;
		}
		Adult.prototype = Object.create(People.prototype);
		Adult.prototype.work = function(){
			console.log(this.age+this.name+this.job)
		}
		var adult = new Adult("成年人",35,"上班");
		adult.say();
		adult.work();
		var people = new People("人类",70)
		people.say();
		</pre>
		<p class="textIndent">在我们平时的开发中，通常把属性定义在函数中，把函数定义在构造函数的原型中</p>
		<p class="textIndent">所以在在使用继承的时候我们需要考虑两个方面一个是属性的技能，一个是方法的继承
		。通常我们使用函数.call(this)来实现属性的继承，call方法的作用是执行前面的函数，
		同时将函数里面的this替换为第一个参数，后面参数就是执行函数的里面的参数</p>
		<p class="textIndent">属性的继承有多种方式我们常用的方式有两种，一种是通过Object.create()方式形成
		一条原型链，
		使子类可以通过该原型链访问到父类的原型上面的方法，同时也可以实现继承里面的方法覆盖，子列修改
		继承的方法不会影响父类的构造方法，因为子类在自身上面寻找到了该方法就不会到父类的原型上去查找。
		这种方式下我们需要改变子类的constructor的指向自己的构造函数。</p>
		<p class="textIndent">方法继承的常用第二种方式为对象的深拷贝，因为函数.prototype是一个对象，而方法
		就是该对象上面
		的属性，所以我们可以通过继承来讲父类原型上面的方法拷贝到子类的原型上，常用继承方法都可以实现
		该功能</p>
		<pre>
		function extend(_new,old){
			for(var item in old){
				_new[item] = old[item]
			}
		}
		function extend(a){
			return JSON.parse(JSON.stringify(a));
		}
		</pre>
		</div>
	</div>
 </div>

<div class="navbar navbar-default clearMB">
		<div class="container">
			
		
		</div>
	</div>
 </body>
</html>
