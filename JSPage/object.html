<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=devich-width, initial-scale=1">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  
  <title>Shinhwa</title>
  <link href="../css/bootstrap.css" rel="stylesheet">
  <link rel="shortcut icon" href="../favicon.ico" />
  <script src="../js/jquery.js"></script>
  <script src="../js/bootstrap.min.js"></script>
  <style>
  .textIndent{text-indent:2em;line-height:2em}
  .line{height:1px;border-top:1px solid red;margin-bottom:10px}
  .title{background-color:#7777A4;padding:10px;color:white}
  .clearMB{margin-bottom:0!important}
  .mt{margin-top:50px}
  </style>
  <script>
  
  
  </script>
 </head>
 <body>
  <div class="navbar navbar-default navbar-fixed-top">
	<div class="navbar-header">
		<button data-toggle="collapse" class="navbar-toggle" data-target=".navbar-responsive-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="../homePage.html">对象</a>
	</div>
	<div class="collapse navbar-collapse navbar-responsive-collapse">
		<ul class="nav navbar-nav">
			<li><a href="#create">对象的创建</a></li>
			<li><a href="#prop">对象的属性</a></li>
			<li><a href="#serialize">对象的序列化</a></li>
		</ul>
	</div>
 </div>
 <div class="container mt">
	<div class="row">
		<div class="col-lg-12">
		<h3 class="title" id="create">对象的创建的三种方式</h3>
		<p class="textIndent">1.对象字面量创建</p>
		<pre>
		var a = {};
		//这种方式创建的对象的原型为Object.prototype
		</pre>
		<p class="textIndent">2.new操作符</p>
		<pre>
		var a = new Object();
		//这种方式创建的对象的原型为构造函数的原型
		</pre>
		<p class="textIndent">new操作符会创建一个对象实例,在这个过程中主要包括三个部分，1属性的初始化，
		2原型的继承，3改变
		this的指向。new操作符后面的函数称之为构造函数，在new的过程中，会把构造函数的属性添加到要被创建
		得对象的身上，同时新对象的原型会指向构造函数的原型，this也同样会指向新创建出来的对象。新创建的
		对象即构造函数的一个实例，拥有构造函数的属性和方法</p>
		<pre>
		function People(name,age){
			this.name = name;
			this.age = age;
		}
		People.prototype.skill = function(){
			alert("coding");
		}
		//上面是创建的一个构造函数
		var me = new People("zt",22);
		//上面是我们创建的一个对象，new过程的三个部分完成之后会创建出一个me对象
		//此时的me对象等价于{name:"zt",age:22,skill:function(){}},真正的skill函数是通过原型才能够访问到的！
		</pre>
		<p class="textIndent">3.Object.create()</p>
		<pre>
		var a = Object.create(Object.prorotype);//参数是一个对象
		//该方法的解释为创建一个对象，并且该对象的原型指向第一个参数，新对象继承了参数对象
		var b = Object.create(null);
		//b对象是一个真正的空对象不具有任何属性和方法
		</pre>
		<div class="line"></div>
		<h3 class="title" id="prop">属性</h3>
		属性即对对象的一个说明，就像一个人，别人形容你会说身高，体型。
		<pre>
		var me = {};
		me.name = "zt";
		me.age = 22;
		//name,age就是me对象的属性
		//我们也可以用下面的方式声明
		var me = {name:"zt",age:22};
		</pre>
		<p class="textIndent">在我们平时的开发中，在进行前后数据交互的时候，如果是AJAX简单的数据交互我们可
		以使用
		JQ提供的$("form").serialize()来发送我们数据，如果是复杂的数据格式，我们就需要自己组装
		需要发送的数据，如果只是单一的情况我们使用上面的代码中的下面的方式组装对象即可，
		如果存在多种情况我们使用上面的对象声明方式更加合理(可读性较高)。</p>
		<pre>
		var sendData = {};
		sendData.name = "name";
		sendData.descirtion = "description";
		if(isSome){//在某种情况下
			sendData.flag = "admin";
		}else{
			sendData.flag = "user";
		}
		//上面的if可以简写成isSome?sendData.flag = admin:sendData.flag = user
		if(isSome){
			var sendData = {
				name:"name",
				description:"description",
				flag = "admin"
			}
		}else{
			var sendData = {
				name:"name",
				description:"description",
				flag = "user"
			}
		}
		//感觉上面的方式写起来更好
		//混合写……
		var sendData = {
			name:"name",
			description:"description"
		}
		isSome?sendData.flag = "admin":sendData.flag = "user";
		</pre>
		<h4>属性的get/set方法</h4>
		<pre>
		var a = {
			name:"zt",
			set age(arg){
				do sth by arg
			},
			get age(){
				var currentDate = new Date();
				var currentYear = currentDate.getFullYear();
				
				return currentYear-1993+1;
			}
		}
		//属性的读取和设置
		</pre>
		属性是可以删除的
		<pre>
		var a = 10;
		b = 11;
		//没有通过var操作符声明的并不是产生一个全局变量，而是作为一个属性被附加到了window对象上，可以删除
		//全局变量也是可以通过window访问到的window.a -> 10;当时不能为删除
		//delete window.a -> false
		//delete window.b -> true
		</pre>
		<p class="textIndent">属性特性</p>
		<p class="textIndent">属性特性包括，值(value)、可写(writable)、可枚举(enumerable)->决定属性能不能
		被循环到、可配置(configable)</p>
		<p class="textIndent">常用API如下：</p>
		<pre>
		Object.getOwnPropertyDescriptor();//得到自有属性描述 不能得到继承的属性
		//该方法接受两个参数第一个参数为对象，第二个参数为对象的一个属性(属性要加上"")
		Object.defineProperty();//设置属性的特性
		//该方法接受三个参数，第一个参数为对象，第二个参数为对象的一个属性，第三个参数为对该属性的特性设置
		//第三个参数的格式为json ->{value:"1",writable:true,enumerable:false,configurable:true}
		Object.defineProperties();//可以设置多个对象的特性
		//该方法接受两个参数，第一个参数是要修改的目标对象，第二个参数是一个JSON格式的对象
		//第二个参数对象的key为属性value为该属性的配置
		Object.isExtensible()//判断对象是否是可扩展的
		//该方法接受一个参数，参数为我们的目标对象
		Object.preventExtensions()//将对象设置为不可扩展，接受一个对象作为参数
		Object.seal()//将对象设置为不可扩展,同时不可配置，接受一个对象作为参数
		Object.freeze()//将对象设置为不可扩展,同时不可配置，属性设为只读，接受一个对象作为参数
		Object.isFrozen()//检测对象是否冻结
		</pre>
		<div class="line"></div>
		<h3 class="title" id="serialize">对象的序列化</h3>
		<pre>
		JSON.stringify();//将对象序列化为对象字符串
		JSON.parse();将对象字符串还原成对象
		//在AJAX中我们在发送数据时需要使用JSON.stringify()将我们要发送的对象进行序列化
		//接收数据的时候需要使用JSON.parse()将对象字符串进行反序列化成对象
		//使用方式如下：
		var a = {name:"zt",age:22};
		var str = JSON.stringify(a);//"{"name":"zt","age":22}"
		var _a = JSON.parse(str);//{name: "zt", age: 22}
		</pre>
		<p class="textIndent"> JSON.stringify()和JSON.parse()结合使用可以完成对对象的深拷贝</p>
		<pre>
		function extend(obj){
			return JSON.parse(JSON.stringify(obj))
		}
		</pre>



		</div>
	</div>
 </div>
 <div class="navbar navbar-default clearMB">
		<div class="container">
		
		</div>
	</div>
 </body>
</html>
